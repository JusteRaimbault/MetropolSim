
;;;;;;;;;;;;;;;;
;; governance
;;;;;;;;;;;;;;;;


;; 
;  Transportation network evolution (governance part of the model)
;
;  Contiguous actors with most wealth take decision ; or top-down regional planning.
;
;
to governance
  
  output-print "governance"
  
  ; get agents making the decision
  let decidors decision-makers
  
  ; corresponding potential place for infrastructures
  ;let infra-choices potential-infrastructures decidors
  
  let old-config save-nw-config
  ; construct the best one
  construct-infrastructure (best-infrastructure decidors old-config) old-config
  
  ; recompute patch vars here - as indicators are called after the end of this stage.
  ;  Q : to gain perf, do it only at the end ? -- OK not so much time
  compute-patches-variables
  
end


;;
; Gets mayors taking the decision at this step - can be region ?
to-report decision-makers
  
  ifelse random-float 1 < regional-decision-proba [
     ; regional decision
     report regional-authority
  ][
     ; local decision : choose according to wealth
     ; choose neighbor pairs with maximal weight
     ; dirty way ok as very few mayors
     ;
     ;  -- TODO -- for now not random
     ;
     ;  @TODO implement various ways to choose constructors ?
     ;
     let ma 0 let maxpair []
     ask mayors[ask other mayors [let etot [employments] of self + [employments] of myself if etot > ma [set ma etot set maxpair (list self myself)]]]
     report maxpair
  ]
  
end


;;
; Reports a list of potential infras (which format ?)
;
;  FIND Heuristic in order to exploit reduced part of the space (already too long with very few patches if in O(n^2)
;  here no game, report indifferently common and alone infras ? or report with distinct feature ?
to-report potential-infrastructures [decidors]
  let res []
  ifelse decidors = regional-authority [
    repeat #-explorations [
      set res lput (random-infra patches (2 * road-length)) res
    ]
  ][
    repeat #-explorations [
      set res lput (random-infra (patches with [member? governing-mayor decidors]) road-length) res
    ]
  ]
  report res
end


;;
; Given a set of choices and decidors, find the best infrastructure
;
;  Implement the game between the two players here -> evaluate all costs (have to be done anyway), then draw randomly issue of the game according to individual utilities 
;
;  @returns list of coordinates of extremities (better not to construct links here -> sure, as capacity congestion etc are not used at this step : only matrix needed.
to-report best-infrastructure [decidors old-config]
  
  ifelse decidors = regional-authority [
    ; no game, find the best among the choices
    report first compare-infrastructures old-config potential-infrastructures regional-authority
  ][  
    ; generate potential infras here
    ; assume 2 decidors
    let dec1 first decidors let dec2 last decidors
    let best1 compare-infrastructures old-config potential-infrastructures (list dec1)
    let best2 compare-infrastructures old-config potential-infrastructures (list dec2)
    let best12 compare-infrastructures old-config potential-infrastructures decidors
    
    ; report game result given these explorations
    report game-result best1 best2 best12
  ]
  
end



;;
; raw comparison of infras : needs old configuration of a-e ? yes nw config for shortest paths
;
;  @TODO
;  -- NOTE -- for mean-acc ; shouldn't it be only on patches concerned by the decidor ?
;    --> clarify this point
;
to-report compare-infrastructures [old-nw-config choices]
  verbose (word "comparing " length choices " infras")
  
  recall-nw-config old-nw-config
  
  ; old mean accessibility
  compute-patches-accessibilities
  let old-acc mean-accessibility
  verbose mean-travel-distance
  
  let best-choice [] let delta-acc 0
  foreach choices [
    recall-nw-config old-nw-config
    let potential-infra new-infra ?
    update-network potential-infra
    update-effective-matrices
    ; recompute new accessibilities
    compute-patches-accessibilities
    let new-acc mean-accessibility
    
    ; check if better delta-acc
    verbose (word "∆Z=" (new-acc - old-acc))
    verbose (word "mean-travel-distance = " mean-travel-distance)
    
    if (new-acc - old-acc) > delta-acc [set best-choice ? set delta-acc (new-acc - old-acc)]
    
    ; kill the potential infra, will be reconstructed if indeed the best
    ask potential-infra [ask both-ends [die] die]
    
    ; color patch here ? should be supressed for performance
    color-patches
  ]
  
  verbose (word "best infra is " best-choice " with ∆Z=" delta-acc)
  
  report (list best-choice delta-acc)
end



;;
; Implement the game between the two actors
to-report game-result [best1 best2 best12]
    ; implement game : need to check proba formula.
  
   if game-type = "random" [
    ; Random = no game
    let r random 3
    if r = 1 [report first best1] if r = 2 [report first best2]
    if r = 0 [report first best12]
   ]
   
   
end



;;
; Construct the given infrastructure
;
; Update matrices distances etc here !
to construct-infrastructure [infra old-config]
  
  ; construct the infra if not empty
  if infra != [] [
    recall-nw-config old-config
    
    let new-link new-infra infra
    
    ; update matrices
    update-network new-link
    update-effective-matrices
    
    ; then correct the network by planarization if intersecting links.
    ; Beware, has to be done AFTER updating matrices, as nw updating needs footprint of the link (fastest way to get patches newly connected to the network
    ;  but planarizing before would kill the entire links, cutting it into smaller
    planarize-network transportation-nodes transportation-links
  ]
  
end


;; report the link corresponding to coordinates
to-report new-infra [coords]
  let e1 nobody let new-link nobody
  create-transportation-nodes 1 [new-transportation-node setxy first first coords last first coords set e1 self]
  create-transportation-nodes 1 [
    new-transportation-node setxy first last coords last last coords
    create-transportation-link-with e1 [new-transportation-link set new-link self]
  ]
  report new-link
end




to-report random-infra [patchset infra-length]
  let p1 one-of patchset
  let p2 nobody if p1 != nobody [ask p1 [set p2 one-of patchset with [abs(distance myself - infra-length) < 1]]]
  if p2 = nobody [ if p1 != nobody [ask p1 [set p2 one-of patchset with [distance myself < infra-length]]]]
  ifelse p2 = nobody or p1 = nobody [report (list (list random-xcor random-ycor) (list random-xcor random-ycor))][
  report (list (list [pxcor] of p1 [pycor] of p1) (list [pxcor] of p2 [pycor] of p2))  
  ]
end








