;;function called in a particular context

;;Create an abstract network of breeds vertexes, paths if and only if :

;;  -  paths-layer-data is a gis polyline layer
;;  -  global var cluster-treshold, remaining-links, remaining-vertices has been defined (not initialised, no pb)
;;  -  breed vertexes, undirected-link-breed paths and breed abstract-gis-pathshas been defined, with corresponding variables, that means in code :

;;         breed [vertices vertex]
;;         breed [abstract-gis-paths abstract-gis-path]

;;         abstract-gis-paths-own [
;;             gis-feature
;;             vertices-list
;;          ]

;;         undirected-link-breed [paths path]

;;         paths-own [path-length]

;;  -  LinkUtilities.nls is in the includes 
;;  -  ListUtilities.nls is in the includes 







to create-network-vertices-clustering

  foreach gis:feature-list-of paths-layer-data [
    let abstract nobody
    let current-vertex nobody
    create-abstract-gis-paths 1 [set gis-feature ? new-abstract-gis-path set abstract self]
    foreach gis:vertex-lists-of ? [
      foreach list first ? last ? [
       let loc gis:location-of ? if loc != [][
       create-vertices 1 [
         setxy min list first loc max-pxcor min list first but-first loc max-pycor
         new-vertex 
         ask abstract [set vertices-list lput myself vertices-list]
         ifelse current-vertex = nobody [set current-vertex self][ask current-vertex [create-path-with myself [new-path
               ]] set current-vertex self]
         ]
         
       ]
      ]
      set current-vertex nobody
    ]
  ]
  
  
  ;;try a simple local clusterize?

  set remaining-vertices to-list vertices
  ;reset-ticks
  while [length remaining-vertices > 0][
    let v first remaining-vertices set remaining-vertices remove v remaining-vertices ask v [set color blue]
    ask v [fusion-neighbors]
    ;tick
  ]
  
  
  
end



to fusion-neighbors

   let neigh other vertices in-radius cluster-treshold
   if count neigh > 0 [
    let n nobody
    let x mean [xcor] of neigh
    let y mean [ycor] of neigh
    hatch-vertices 1 [
      set n self
      setxy x y
      ask neigh [
         set remaining-vertices remove self remaining-vertices
         ask my-paths [if not member? other-end neigh and other-end != n [ask other-end [create-path-with n]] die]
         die
      ]
    ]
    ask my-paths [if not member? other-end neigh and other-end != n [ask other-end [create-path-with n]] die]
    die
   ]
end











;;;;;;;
;; This shitty function seems deprecated
;; -> impossible to use in large complexity cases
;; Should write a new one using fast clustering and intersection after
;;
;; Try to improve complexity of "intersecting" function
;;;;;;;

to create-network
  set remaining-links []
  
  ;;paths layer is supposed to match the world enveloppe BUT pb sometimes (not exact enveloppe?)
  ;; so in that case, create the vertex anyway but by putting it in edge of the world
  
  foreach gis:feature-list-of paths-layer-data [
    let abstract nobody
    let current-vertex nobody
    create-abstract-gis-paths 1 [set gis-feature ? new-abstract-gis-path set abstract self]
    foreach first gis:vertex-lists-of ? [
       let loc gis:location-of ? if loc != [][
       create-vertices 1 [
         setxy min list first loc max-pxcor min list first but-first loc max-pycor
         new-vertex 
         ask abstract [set vertices-list lput myself vertices-list]
         ifelse current-vertex = nobody [set current-vertex self][ask current-vertex [create-path-with myself [new-path]] set current-vertex self]
         ]
         
       ]
    ]
  ]
  
  ;local-clusterize
  
  set remaining-vertices to-list vertices
  while [length remaining-vertices > 0][
    let v first remaining-vertices set remaining-vertices remove v remaining-vertices ask v [set color blue]
    ask v [fusion-neighbors]
  ]
  
  
  
  
  
  
  set remaining-links to-list paths
  while [length remaining-links > 0] [
    ;show length remaining-links
    let l one-of remaining-links set remaining-links remove l remaining-links ask l [set color blue set thickness path-thickness]
    let inter intersecting l
    if inter != nobody [
      let i intersection l inter
      let x first i let y first but-first i
      create-vertices 1 [new-vertex setxy x y create-path-with [end1] of l [set remaining-links lput self remaining-links]
      create-path-with [end2] of l [set remaining-links lput self remaining-links ]
      create-path-with [end1] of inter [set remaining-links lput self remaining-links ]
      create-path-with [end2] of inter [set remaining-links lput self remaining-links]]
      ask l [ die ] ask inter [die] set remaining-links remove inter remaining-links
    ]
    
  ]
  
  ;local-clusterize
  
  
  ask vertices [set color blue]
  ask paths [set color blue set thickness path-thickness]
  
end


;;particular reduction of network by clustering. (adapted to the network creation procedure and to the real world gis network we work with)
to local-clusterize
    ;;deleting local clusters
  set remaining-vertices to-list vertices
  while [length remaining-vertices > 0][
    let v one-of remaining-vertices set remaining-vertices remove v remaining-vertices ask v [set color blue]
    let neigh vertices with [member? self remaining-vertices and distance v < cluster-treshold and self != v]
    ifelse count neigh > 0 [ask one-of neigh [fusion v]]
    
    
    ;;in the other case, if exists one link with distance < epsilon, create a vertex at the projection location 
    ;;added this requirement to have quite in each case a connex network, because then two very close link will connect although they don't intersect at the small scale
    
    
    [ask v [let ml my-paths let x xcor let y ycor let ps paths with [not member? self ml and distance-to-point x y < cluster-treshold] if count ps > 0 [ask one-of ps [
          let p coord-of-projection-of x y let xx first p let yy first but-first p let e1 end1 let e2 end2 ask e1 [hatch-vertices 1 [
              setxy xx yy
              create-path-with e1 [set thickness 1] ; thickness for debug purposes at the beginning
              create-path-with e2 [set thickness 1]
              fusion v           
     ]]
     die  ; the old link
    ]]]]
  ]
  
  
  ask vertices [set color blue]
  ask paths [set color blue set thickness 0.3]
end

to fusion [v]
  set remaining-vertices remove self remaining-vertices 
  let v1 self let v2 v
  ;show "fusion" 
  ;show v1
  ;show v2
  let x ([xcor] of v1 + [xcor] of v2) / 2
  let y ([ycor] of v1 + [ycor] of v2) / 2
  hatch-vertices 1 [setxy x y
    let n self
    ;show word "n:" n
    ask ([my-paths] of v1) with [end1 != v2 and end2 != v2] [show self ifelse end1 = v1 [ask end2 [create-path-with n]][ask end1 [create-path-with n]] die]
    ask ([my-paths] of v2) with [end1 != v1 and end2 != v1] [show self ifelse end1 = v2 [ask end2 [create-path-with n]][ask end1 [create-path-with n]] die]
    ask ([my-paths] of v1) [if end1 = v2 or end2 = v2 [die]]
    ask v1 [die]
    ask v2 [die]
    set remaining-vertices lput self remaining-vertices
  ]
end

to-report intersecting [l]
  ;;hard complexity :(
  ;;ok improved by selecting eligible links before the loop !
  let res nobody
  let found? false
  let r-links to-list paths with [self != l and intersection self l != []]
  while [not found? and length r-links > 0][
    let l1 one-of r-links set r-links remove l1 r-links
    if not common-extremity? l l1 [set res l1 set found? true]
  ]
  report res
end

to-report common-extremity? [l1 l2]
  report [end1] of l1 = [end1] of l2 or [end1] of l1 = [end2] of l2 or [end2] of l1 = [end2] of l2 or [end1] of l2 = [end2] of l1
end



to new-vertex
  set size vertex-size
  set shape "circle" set color grey
end

to new-abstract-gis-path
  set hidden? true  set vertices-list []
end

to new-path
  set thickness path-thickness set color blue
end






;;;;;;;;;;;
;; Calcul of distances in the network
;;;;;;;;;;;

;; Requires : nw extension set
;; same breeds as before (need path length for weighted distance !)


;;turtle procedure : distance to other turtle through network
;;snapshot and link distance done in other function, so done just 1 time (efficiency!)

to snapshot
  nw:set-snapshot vertices paths
  ask paths [let dd 0 let e2 end2 ask end1 [set dd distance e2 ] set path-length dd * real-patch-size]
end

;;beware, need snapshot before !
to-report distance-through-network [target-turtle]
  let origin first sort-on [distance myself] vertices
  let destination nobody ask target-turtle [set destination first sort-on [distance myself] vertices]
  let res 0
  ask origin [set res nw:weighted-distance-to destination "path-length"]
  ;if res = false [ask origin [set size 3 set hidden? false] ask destination [set size 3 set hidden? false]]  ;;Hardcore DEBUG
  if res = false [set res 0] ;;Beware : in theory infinity, but for norms calculations, just not taken into account, so ok ; for other use not coherent behavior
  ;; SO : network MUST be connex !!!
  ;;add this fix to avoid bugs but can produce instable results
  
  
  ;;should add both euclidian distances ? Yes, more precise in that case !
  ;; BUT could exist some cases where the final distance is not the shortest. 
  ;;(if network can be reached through projection on links. If network can be entered only by vertexes? also counter-examples of that fact??? Yes...
  ;; but still, should be good approximation in realistic cases. (on random networks?) (write something on that?)
  let dt 0 ask target-turtle [set dt distance destination]
  
  report (distance origin) + res + dt
end












