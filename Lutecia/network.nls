
;;;;;;;;;;;;;;
;; Transportation Network functions
;;;;;;;;;;;;;;






;; report the link corresponding to coordinates
to-report network:new-infra [coords]
  let e1 nobody let new-link nobody
  ifelse length first coords = 2 and length last coords = 2[
  create-transportation-nodes 1 [new-transportation-node setxy first first coords last first coords set e1 self]
  create-transportation-nodes 1 [
    new-transportation-node setxy first last coords last last coords
    create-transportation-link-with e1 [new-transportation-link set new-link self]
  ]
  
  ; check if link is valid
  let valid? false
  ask new-link [
    foreach footprint [ask ? [set valid? (valid? or not member? number nw-patches)]]
  ]
  ifelse valid? [
    report new-link
  ][
    verbose "¡¡ Unvalid infrastructure !!"
    ask new-link [ask both-ends [die] die]
    report nobody
  ]
  ][report nobody]
end





to-report network:random-infra [patchset infra-length]
  ; first end is taken in patchset
  let p1 one-of patchset
  
  ; fixed infra length
  let p2 nobody if p1 != nobody [ask p1 [set p2 one-of patchset with [abs(distance myself - infra-length) < 1.5]]]
  if p2 = nobody [ if p1 != nobody [ask p1 [set p2 one-of patchset with [distance myself < infra-length]]]]
  if p2 = nobody [ if p1 != nobody [ask p1 [set p2 one-of patches with [abs(distance myself - infra-length) < 1.5]]]] ; if patchset too small, test other end on all patches
  
  let c1 [] let c2 []
  
  ifelse p2 = nobody or p1 = nobody [
    set c1 (list random-pxcor random-pycor) set c2 (list random-pxcor random-pycor)
  ][
    ; for each existing infrastructure, check if closer than snapping threshold, report projection if needed
    set c1 (list [pxcor] of p1 [pycor] of p1) set c2 (list [pxcor] of p2 [pycor] of p2)
    ask transportation-links [
       ask p1 [
         if distance-to-link myself < infra-snapping-tolerance [
           ask myself [set c1 coord-of-projection-of ([pxcor] of p1) ([pycor] of p1)]
         ]
       ]
       ask p2 [
         if distance-to-link myself < infra-snapping-tolerance [
           ask myself [set c2 coord-of-projection-of ([pxcor] of p2) ([pycor] of p2)]
         ]
       ]
    ]
    
    
  ]
  
  ifelse (first c1 = first c2 and last c1 = last c2) or (first c1 = last c2 and last c1 = first c2)[
      report (list [] []) 
    ]
    [
      report (list c1 c2) 
    ] 
end








to new-transportation-node
  set shape "circle" set size 0.4 set color red
end


to new-transportation-link
  set color red set thickness 0.4
  
  ; define capacity ?
  
  
  ; age -> done at the end of construction
  ;set age ticks
  
end


;;
;  memorize links age in a table
to-report nw-age
  let res table:make
  ask transportation-links [
    foreach footprint [
      ask ? [
        table:put res number ([age] of myself)
      ]
    ] 
  ]
  report res
end


;;
;  Update age variable of links
;    with memorized nw-age in table patch -> age
to update-network-age [old-nw-age]
  ask transportation-links [
    let new-age 0 let ages rep 0 (ticks + 1); ages memorized in a list
    foreach footprint [
      ask ? [
         ifelse table:has-key? old-nw-age number [
           let a table:get old-nw-age number
           set ages replace-item a ages ((item a ages) + 1)
         ][
           set ages replace-item ticks ages ((item ticks ages) + 1)
         ]
      ]
    ]
    ; age is element with max value
    set age max-index ages
  ]
  
  update-nw-display
  
  
end